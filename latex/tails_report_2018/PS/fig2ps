eval '(exit $?0)' && eval 'exec perl -s -S $0 ${1+"$@"}' && eval 'exec perl -s -S $0 $argv:q' if 0;

use Env qw(HOME EDITOR);
use Fatal qw(open close);
use strict;

=head1

One-liner: transformer un .fig en .ps .

Exemple: fig2ps truc.fig

Principe: on souhaite pouvoir dessiner avec XFig des dessins à inclure dans un 
fichier LaTeX. XFig fournit déjà des mécanismes pour cela puisque l'on peut 
exporter depuis ce logiciel aux formats .eepic (commandes TeX natives), 
combiné PostScript/LaTeX ou PostScript. Chacune de ces solutions a hélas des 
inconvénients incompatibles avec la rédaction d'un ouvrage distribué sur 
plusieurs auteurs: les versions de XFig ne sont pas pleinement compatibles 
entre elles pour les .eepic, et on bute alors sur les limitations des 
primitives graphiques LaTeX; les combinés PostScript/LaTeX saturent rapidement 
la mémoire de TeX quand on les inclut tels quels; et on ne peut pas utiliser 
de commande LaTeX dans le dessin si on exporte en PostScript. Ce programme 
résout tous ces problèmes en générant un fichier .ps (PostScript) à partir de 
votre .fig, qui peut contenir des commandes LaTeX, y compris celles définies 
dans le fichier de macros "annales.sty".

Si dans XFig vous utilisez une police de taille 10, vous pouvez inclure le 
fichier PostScript ainsi produit dans votre fichier LaTeX sans préciser sa 
largeur (width=) ni sa hauteur (height=):
	\centers{\epsfig{file=blah.ps, clip=}}
(Utilisez toujours l'option "clip=", ceci sans deuxième membre à droite du 
signe "=").

Par défaut, ce programme cherche à charger le fichier "annales.sty". Vous 
pouvez l'en empêcher avec l'option -basic, par exemple pour rédiger un article 
ou une thèse. (Vous pourrez quand même utiliser \e dans XFig.)

Si dans le fichier PostScript produit par ce programme une partie du dessin 
était coupée (ou une annotation), utilisez les options ci-dessous pour ajuster 
la "fenêtre" (BoundingBox) visible.

Pour davantage d'informations sur la manière de réaliser votre dessin avec
XFig, veuillez consulter la Doc en ligne sur auteurs.H-K.fr .

Ce programme peut être utilisé par toute personne, à des fins personnelles ou 
strictement académiques. Son emploi pour réaliser des travaux commerciaux, 
comme des ouvrages non publiés par les Éditions H&K, est soumis à condition: 
veuillez dans ce cas prendre contact avec nous (contact@h-k.fr).

Options: 
		-dbg		Debug: garder les fichiers intermédiaires
		-basic		Ne pas utiliser annales.sty.
		-nogv		Ne pas lancer 'gv' pour montrer le résultat

		# Options pour ajuster la BoundingBox.
[100%]	-morewidth="xx%"	Agrandir la largeur par un facteur donné en %
[100%]	-moreheight="xx%"	Agrandir la hauteur par un facteur donné en %
[0]		-leftshift=xxx		Décaler l'image vers la gauche de xxx points.
[0]		-upshift=xxx		Décaler l'image vers le haut de xxx points.

											© Seb, 20 novembre 2001
											  Réécriture le 2011-01-21

=cut

our $e and exec "$EDITOR $0";

our ($dbg, $basic, $nogs, $nogv, $morewidth, $moreheight, $leftshift, 
	$upshift);

##
## Initialisation.
##

# Le fichier .fig .
(!@ARGV) and exec "perldoc -u $0";
my $fig = shift();
$fig =~ s{(^\s+|\s+$)}{}g;
(! -e $fig) and die "Le fichier |$fig| n'existe pas !\n";
(! -f $fig) and die "|$fig| existe mais n'est pas un fichier !\n";
($fig !~ /\.fig$/) and die "Le fichier |$fig| n'a pas le suffixe .fig, ce n'est pas une sauvegarde simple sans export !\n";

# On élimine les espaces dans le nom du fichier .fig .
(my $fig_no_spaces = $fig) =~ s{\s+}{-}g;
if ($fig ne $fig_no_spaces) {
	print "\n\t$fig ->\n\t$fig_no_spaces\n";
	system qq{\mv "$fig" "$fig_no_spaces"};
	$fig = $fig_no_spaces;
}

# Il est plus pratique de manipuler le préfixe du fichier.
(my $prefix = $fig) =~ s{\.fig$}{};
($prefix eq $fig) and die "Conflit de noms avec |$fig|: bizarre !\n";

# Fichiers intermédiaires.
my $tmp = "tmp." . time();

# Options pour 'dvips'.
my $dvips = "dvips -tunknown -R0 -j0";

# Pour bidouiller la largeur ou la hauteur.
$morewidth  =~ s{,}{.};
$morewidth  =~ s{[^\d\.]}{}g;
$moreheight =~ s{,}{.};
$moreheight =~ s{[^\d\.]}{}g;
my $mult_width  = 1 + $morewidth /100;
my $mult_height = 1 + $moreheight/100;


##
## Conversion du .fig avec 'fig2dev'. On crée d'une part un fichier PostScript
## qui ne contient que les dessins, sans les annotations, d'autre part un 
## fichier TeX qui appelle le PostScript et y superpose les annotations 
## (Vince).
##

if (`which fig2dev` =~ /not\s*found/i) {
	die   "Je ne trouve pas le programme 'fig2dev' dans le système.\n"
		. "Veuillez m'appeler sur un fichier .eepic produit par XFig.\n"
		;
}

# On ajuste le fichier .fig: flags, '%', '&', etc.
&fix_dot_fig($fig);

# Création du fichier PostScript ne contenant que le dessin.
my $err_mesg = `fig2dev -L pstex "$prefix.fig" > "$prefix.$tmp.img.ps"`;
($err_mesg) and die "\nJe rencontre un problème insurmontable: lors de la traduction de\n\t$prefix.fig\nen\t$prefix.$tmp.img.ps\nl'erreur suivante est apparue dans fig2dev:\n\n$err_mesg\n";

# Création de code LaTeX à insérer plus bas dans un fichier.
my $latex_code = `fig2dev -L pstex_t -p "$prefix.$tmp.img.ps" "$prefix.fig"`;

##
## Recherche d'annales.sty (utilisation dans les Annales H&K).
##

my $annales_sty;
if (!$basic) {
	foreach my $dir (
		".",
		"..",
		"$HOME/Annales/data",
	) {
		if (-f "$dir/annales.sty") {
			$annales_sty = "$dir/annales.sty";
			last;
		}
	}
	(! -f $annales_sty) and die "Échec: je n'ai pas trouvé de chemin vers annales.sty...\n";
}


##
## Écriture du fichier LaTeX qui inclut le dessin.
##

my $input;
if ($basic) {
	$input = "\\documentclass{article}\n"
	. "\\usepackage{vmargin}\n"
	. "\\usepackage{amsmath}\n"
	. "\\usepackage{grffile}\n"
	. "\\usepackage[cmyk]{xcolor}\n"
	. "\\usepackage[T1]{fontenc}\n"
	. "\\usepackage[latin1]{inputenc}\n\n"
	. "\\mathcode`A=\"7041 \\mathcode`B=\"7042\n"
	. "\\mathcode`C=\"7043 \\mathcode`D=\"7044\n"
	. "\\mathcode`E=\"7045 \\mathcode`F=\"7046\n"
	. "\\mathcode`G=\"7047 \\mathcode`H=\"7048\n"
	. "\\mathcode`I=\"7049 \\mathcode`J=\"704A\n"
	. "\\mathcode`K=\"704B \\mathcode`L=\"704C\n"
	. "\\mathcode`M=\"704D \\mathcode`N=\"704E\n"
	. "\\mathcode`O=\"704F \\mathcode`P=\"7050\n"
	. "\\mathcode`Q=\"7051 \\mathcode`R=\"7052\n"
	. "\\mathcode`S=\"7053 \\mathcode`T=\"7054\n"
	. "\\mathcode`U=\"7055 \\mathcode`V=\"7056\n"
	. "\\mathcode`W=\"7057 \\mathcode`X=\"7058\n"
	. "\\mathcode`Y=\"7059 \\mathcode`Z=\"705A\n"
	. "\\newcommand{\\e}[1]{\\ensuremath{{}_{\\text{\#1}}}}\n"
	;
}
else {
	$input = "\\input{$annales_sty}\n"
	. "\\usepackage{grffile}\n"
	. "\\usepackage[cmyk]{xcolor}\n"
	;
}

open TEX , '>'."$prefix.$tmp.all.tex";
print TEX "$input"
	, "\\setpapersize{custom}{100cm}{100cm}\n"
	, "\\setmarginsrb{0pt}{0pt}{0pt}{0pt}{0pt}{0pt}{0pt}{0pt}\n"
	#, "\\usepackage{aeguill}\n\n" -> Fait foirer sur TeXLive >= 9
	. "\\usepackage{eurosym}\n"
	, "\\begin{document}\n"
	, "\\pagestyle{empty}\n"
	, "\\noindent\n"
	, "%\n"
	, "% Code généré par 'fig2dev'.\n"
	, "%\n"
	, "$latex_code"
	, "%\n"
	, "% Fin du code généré par 'fig2dev'.\n"
	, "%\n"
	, "\\end{document}\n"
	;
close TEX;

# Amélioration du code LaTeX.
&fix_dot_tex("$prefix.$tmp.all.tex");

##
## Compilation et export en PostScript.
##

system qq{latex "$prefix.$tmp.all.tex" }
	.  qq{ && $dvips "$prefix.$tmp.all.dvi" -o "$prefix.$tmp.all.ps" }
	;


##
## Ajustement de la BoundingBox, sorte de fenêtre qui dit quelles zones du 
## fichier PostScript doivent être visibles, avec GhostScript. (Autre
## méthode possible: ps2eps -B (Teteph), mais elle utilise probablement 
## GhostScript en sous-main.)
##

# Recherche des coordonnées finales de la BoundingBox.
#my $bb = `gs -dNOPAUSE -q -sDEVICE=bbox -sPAPERSIZE=b0 $prefix.$tmp.all.ps < /dev/null 2>&1  | grep '%%Bounding'`;
my $bb = `gs -dNOPAUSE -q -sSAFER -sDEVICE=bbox $prefix.$tmp.all.ps < /dev/null 2>&1  | grep '%%Bounding'`;
$bb =~ s{\%\%BoundingBox\:\s+}{};
my ($LLX, $LLY, $URX, $URY) = split (' ', $bb);

# Ajustements avec les options.
$URX  = $LLX + $mult_width  * ($URX - $LLX);
$LLY  = $URY + $mult_height * ($LLY - $URY);
$LLX -= $leftshift;
$URY += $upshift;

# Ajout d'un pixel autour de la figure, pour le confort de la
# visualisation avec 'gv' (Alex).
--$LLX; --$LLY; ++$URX; ++$URY;

# Insertion de la nouvelle BoudingBox dans le fichier PostScript.
my $BeginPaperSize = 0;
open IN, "$prefix.$tmp.all.ps";
open OUT, '>'."$prefix.ps";
while (<IN>) {
	if (/^\%+BoundingBox/) {
		print OUT "%%BoundingBox: $LLX $LLY $URX $URY\n";
	}

	# Les indications sur les fontes posent parfois des problèmes. Mais
	# dans la TeXLive 2009 cette indication devient indispensable car sinon
	# des indices (type e_y) peuvent disparaître dans les dessins. On les 
	# garde donc.
	#elsif (/^\%\%DocumentFonts/) {}

	# Idem pour les indications sur la taille du papier (pb sur Mac).
	elsif (/^%%EndPaperSize/) {
		$BeginPaperSize=0;
	}
	elsif (/^%%BeginPaperSize/) {
		$BeginPaperSize=1;
	}
	elsif ($BeginPaperSize) {}

	# Tout le reste peut être écrit tel quel.
	else {
		print OUT;
	}
}
close OUT;
close IN;


##
## SAV.
##

system qq{rm $prefix.$tmp.* } unless ($dbg);
system qq{gv "$prefix.ps" &} unless ($nogv);


#######################################################################
###########################                  ##########################
###########################   Les routines   ##########################
###########################                  ##########################
#######################################################################

## Arrondir à deux chiffres après la virgule.
sub round {
	return int($_[0] * 100) / 100;
}

## Améliorer le fichier .tex:
## - Prendre garde aux '%' qui ne sont pas protégés.
sub fix_dot_tex {
	my $tex = shift() or die "Problème dans &fix_dot_tex: argument non reçu.\n";
	(! -f $tex) and die "Problème dans &fix_dot_tex: le fichier |$tex| n'existe pas !\n";
	($tex !~ /\.tex$/) and die "Problème dans &fix_dot_tex: le fichier |$tex| n'est pas un .tex !\n";

	open IN, $tex;
	open TMP, '>'."$tex.tmp";
	while (<IN>) {
		if (/^\\put\(.*makebox\(.*SetFigFont/) {
			# C'est un texte: on s'assure de la présence d'un \ avant %.
			# car c'est un simple oubli 99,99 fois sur 100 et il empêche 
			# alors ce programme de fonctionner.
			s{([^\\])\%(\s*\S)}{$1\\%$2}g;
		}
		print TMP;
	}
	close TMP;
	close IN;

	system qq{\mv $tex.tmp $tex};
}

## Améliorer le .fig, par exemple pour activer le Special Flag.
sub fix_dot_fig {
	my $fig = shift() or die "Problème dans &fix_dot_fig: argument non reçu.\n";
	(! -f $fig) and die "Problème dans &fix_dot_fig: le fichier |$fig| n'existe pas !\n";
	($fig !~ /\.fig$/) and die "Problème dans &fix_dot_fig: le fichier |$fig| n'est pas un .fig !\n";

	open IN, $fig;
	open TMP, '>'."$fig.tmp";
	while (<IN>) {
		if (!/^4.*\\001$/) {
			print TMP; 
			next;
		}
		chomp;
		my ($nomeaning, $align, $color, $depth, $pen, $font,
		    $font_size, $angle, $font_flags, $height, $length, 
		    $x, $y, $string) = split(' ', $_, 14);

		$font_flags |= 2;
		if ($font_flags & 4) {
			if    ($font == -1) {$font = 0; $font_flags &= 11} 
			elsif ($font ==  0) {$font = 1; $font_flags &= 11} 
			elsif ($font ==  1) {$font = 3; $font_flags &= 11} 
			elsif ($font ==  2) {$font = 2; $font_flags &= 11}
		}

		print TMP "$nomeaning"
			, " $align" 
			, " $color"
			, " $depth"
			, " $pen"
			, " $font"
			, " $font_size"
			, " $angle"
			, " $font_flags"
			, " $height"
			, " $length"
			, " $x $y"
			, " $string"
			, "\n"
			;
	}
	close TMP;
	close IN;

	system qq{\mv "$fig.tmp" "$fig"};
}
