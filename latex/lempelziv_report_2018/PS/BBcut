#!/usr/bin/perl -s

use File::Basename;

=head1

Ce script ajuste la BoundingBox d'un fichier postscript ou la MediaBox d'un
fichier PDF en utilisant 'gs'. Les calculs sont automatiques. On peut
spécifier les dimensions à adopter avec l'option -BB (qui vaut pour le
postscript comme pour le PDF).
Attention, ce script est rapide et un peu crado.

Usage: $0 fichier.(ps|pdf)

Options et paramètres:
	-h			Afficher ce mémo et mourir.
	-e			Éditer ce fichier.
	-BB=xxx		La BB à utiliser (PS ou PDF): "0 0 100 100"

											© Seb, 2 juin 2004

Astuce 'pdftk uncompress' fournie par Vincent Fourmond (2005.01.18).

=cut

$h and exec "perldoc -u $0";
$e and exec "$ENV{EDITOR} $0";

## Le fichier à traiter.
my $orig = shift() or exec "perldoc -u $0";
	($orig !~ /\.(e?ps|pdf)$/i) 
		and die "Je ne sais traiter que les fichiers PostScript et PDF.\n";
	$orig =~ s#^\./##;
$name = $orig;
if ($name =~ m#\/#) {$name = basename($orig)}
++$is_PDF if ($orig =~ /\.pdf$/i);

## La copie temporaire.
my $tmp = "/tmp/$name.$$";

## La bonne valeur de la BB.
if (not defined $BB) {
	print "Appel à Ghostscript. Cela peut prendre plusieurs minutes...\n";
	$_BB = `gs -q -sDEVICE=bbox -dBATCH -dNOPAUSE $orig 2>&1 | grep -v -i "HiRes"`;
	chomp $_BB;
	$_BB =~ s#%%BoundingBox:\s*##g;
	$_BB =~ s#0\s*0\s*0\s*0\s*##g;
	my @BB = split("\n" , $_BB);
	map { s#^\s*|\s*$##g } @BB;
	foreach (@BB) {
		next unless (/\d/);
	print $_, "\n";
		my ($llx, $lly, $urx, $ury) = split(' ', $_);
		push @llx, $llx;
		push @lly, $lly;
		push @urx, $urx;
		push @ury, $ury;
	}
	$llx = ( sort {$a<=>$b} @llx )[0]; 
	$lly = ( sort {$a<=>$b} @lly )[0];
	$urx = ( sort {$a<=>$b} @urx )[-1]; 
	$ury = ( sort {$a<=>$b} @ury )[-1]; 
}

$BB ||= "$llx $lly $urx $ury";
$BB = "%%BoundingBox: $BB";

print $BB, "\n";

## Est-ce que le fichier de départ avait une BB ?
my  $had_BB;
if (not $is_PDF) {$had_BB = `grep BoundingBox $orig | wc -l` + 0}
else {$had_BB = 1}

## Modification de $orig en $tmp.
my $first = 1;

# S'il s'agit d'un fichier PDF, on le décompresse.
if ($is_PDF) {
	$uncompressed = "/tmp/uc.$$.$name";
	system "pdftk $orig output $uncompressed uncompress";
	$save_pdf = $orig;
	$orig = $uncompressed;
}

open ORIG, $orig or die "Impossible de lire $orig: $!\n";
open TMP, ">$tmp" or die "Imposible de créer $tmp: $!\n";
while (<ORIG>) {
	if (!$had_BB) {
		print TMP;
		if (/^%!PS-Adobe/) {print TMP $BB, "\n"}
	}
	else {
		if ($is_PDF) {
			if (/^\s*\/MediaBox\s*\[.*\]/ && $first) {
				(my $BB = ( split(':', $BB) )[-1]) =~ s#\s*(.*)\s*#$1#;
				print TMP "/MediaBox [$BB]\n"; 
				$first = 0;
			}
			else {print TMP}
		}
		else {
			next if (/^\%\%HiResBoundingBox/);
			if (/^\%\%BoundingBox/i && $first) {
				print TMP $BB, "\n"; 
				$first = 0;
			}
			else {print TMP}
		}
	}
}
close TMP or die "Imposible de fermer $tmp: $!\n";
close ORIG or die "Impossible de fermer $orig: $!\n";

## On remet le fichier à sa place.
system "mv $tmp $orig";

## Et si c'est un PDF, on le recompresse.
if ($is_PDF) {
	system "pdftk $orig output $save_pdf compress";
	unlink $orig;
}
